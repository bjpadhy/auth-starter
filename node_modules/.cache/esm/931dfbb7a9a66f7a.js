let _,generateSignInToken,sendOTP,InternalError,BadRequestInputError;_a9a‍.x([["isUserActive",()=>isUserActive],["userSignup",()=>userSignup],["userSignin",()=>userSignin],["requestOTP",()=>requestOTP],["resetPassword",()=>resetPassword]]);_a9a‍.w("lodash",[["default",["_"],function(v){_=v}]]);_a9a‍.w("../../../lib/authenticate",[["generateSignInToken",["generateSignInToken"],function(v){generateSignInToken=v}]]);_a9a‍.w("../../../lib/communicator",[["sendOTP",["sendOTP"],function(v){sendOTP=v}]]);_a9a‍.w("../../../lib/error",[["InternalError",["InternalError"],function(v){InternalError=v}],["BadRequestInputError",["BadRequestInputError"],function(v){BadRequestInputError=v}]]);



const User = require("../models/user");

       const isUserActive = async (data) => {
  const user = await User().findActiveUser(_.get(data, "email", data.phone));
  return user ? true : false;
};

       const userSignup = async (data) => {
  try {
    // Check for user existence
    let user = await User.findOne({ email: data.email });
    if (user) throw new BadRequestInputError("User already exists", data);

    user = new User(data);
    return await user.save();
  } catch (error) {
    // Catch mongoose validation errors
    if (error.errors) {
      let errorMessages = [];
      _.forEach(error.errors, ({ properties }) => errorMessages.push(properties.message));
      const newError = new InternalError("Input validation error", errorMessages);
      return { error: newError };
    }

    // Signup errors
    _a9a‍.g.console.error(error);
    return { error };
  }
};

       const userSignin = async (data) => {
  let input = _.get(data, "email", data.phone);
  if (input) {
    // Check if user exists and activate
    let user = await User().findOneAndUpdate({ email: data.email }, { isActive: true });

    if (user) {
      // Authenticate user
      return await _validateCredentials(user, data);
    }

    return { isSuccess: false, error: { errorCode: 404, errorMessage: "User doesn't exist" } };
  }

  return { isSuccess: false, error: { errorCode: 400, errorMessage: "Invalid input" } };
};

const _validateCredentials = async (user, input) => {
  switch (input.method) {
    case "EMAIL_SIGNIN":
      return await _emailSignin(user, input);
    case "OTP_SIGNIN":
      return await _otpSignin(user, input);
    default:
      return { isSuccess: false, error: { errorCode: 500, errorMessage: "Unsupported login method" } };
  }
};

const _emailSignin = async (user, input) => {
  const userID = user._id.toString();
  if (user.isResetPasswordInitiated === false) {
    // Compare password
    const passMatch = await user.comparePassword(input.password);
    return passMatch
      ? { isSuccess: true, token: generateSignInToken({ id: userID, email: user.email, isActive: user.isActive }) }
      : { isSuccess: false, error: { errorCode: 400, errorMessage: "Password mismatch" } };
  }

  // Reset password has been initiated and OTP sent
  return { isSuccess: false, error: { errorCode: 400, errorMessage: "Reset password initiated" } };
};

const _otpSignin = async (user, input) => {
  const userID = user._id.toString();
  const storedOTP = await redis.getAsync(`${userID}`);
  if (!storedOTP) return { isSuccess: false, error: { errorCode: 400, errorMessage: "OTP expired" } };

  if (storedOTP === JSON.stringify(input.otp)) {
    // Remove OTP from redis
    await redis.del(`${userID}`);
    // Return JWT
    return {
      isSuccess: true,
      token: generateSignInToken({ id: userID, email: user.email, isActive: user.isActive }),
    };
  }

  return { isSuccess: false, error: { errorCode: 400, errorMessage: "OTP mismatch" } };
};

       const requestOTP = async (data) => {
  let user = await User().findActiveUser(_.get(data, "email", data.phone));
  if (user) return sendOTP(user, { source: data.source });
  return { isSuccess: false, error: { errorCode: 404, errorMessage: "User doesn't exist" } };
};

       const resetPassword = async (data) => {
  // Compare OTP
  // If match, set password, remove OTP, set isResetPasswordInitiated to false
  // else return
};
